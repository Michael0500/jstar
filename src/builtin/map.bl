class __Entry
	fun new(k, v)
		this.key = k
		this.value = v
		this.next = null
	end

	fun __eq__(o)
		if !(o is __Entry) or o == null then
			return false
		end
		return this.key == o.key and this.value == o.value
	end

	fun __string__()
		return "{" + str(this.key) + ":" + str(this.value) + "}"
	end
end

class HashMap
	fun new(init=null)
		this._size = 16
		this._count = 0
		this._entries = list(16)

		if init != null then
			var iter = init.__iterator__()
			while iter.hasNext() do
				this[iter.next()] = iter.next()
			end
		end
	end

	fun __getEntry(key)
		var i = key.__hash__() % this._size

		var buck = this._entries[i]
		while buck != null do
			if key == buck.key then return buck end
			buck = buck.next
		end

		return null
	end

	fun __addEntry(e)
		var i = e.key.__hash__() % this._size
		e.next = this._entries[i]
		this._entries[i] = e
	end

	fun __grow()
		var oldEntries = this._entries

		this._size *= 2
		this._entries = list(this._size)

		for var e in oldEntries do
			var head = e
			while head != null do
				var a = head
				head = head.next
				this.__addEntry(a)
			end
		end
	end

	fun __get__(key)
		var e = this.__getEntry(key)
		return e.value if e != null else null
	end

	fun __set__(key, val)
		var e = this.__getEntry(key)
		if e != null then
			var old = e.value
			e.value = val
			return old
		end

		// The max load factor is 0.75
		if this._count + 1 > this._size * 0.75 then
			this.__grow()
		end

		this.__addEntry(__Entry(key, val))
		this._count += 1
		return null
	end

	fun remove(key)
		var i = key.__hash__() % this._size

		var prev
		var head = this._entries[i]

		while head != null do
			if key == head.key then
				if prev == null then
					this._entries[i] = head.next
				else
					prev.next = head.next
				end

				this._count -= 1
				return head.value
			end

			prev = head
			head = head.next
		end

		return null
	end

	fun containsKey(key)
		return this.__getEntry(key) != null
	end

	fun containsValue(val)
		var iterator = this.valueIterator()
		while iterator.hasNext() do
			if val == iterator.next() then
				return true
			end
		end
	end

	fun clear()
		for var i = 0; i < this._entries.size(); i += 1 do
			this._entries[i] = null
		end
		this._count = 0
	end

	fun size()
		return this._count
	end

	fun keySet()
		return __KeySet(this)
	end

	fun keyIterator()
		return __KeyIterator(this)
	end

	fun valueIterator()
		return __ValueIterator(this)
	end

	fun __string__()
		var s = "["
		var count = 0
		var iterator = __EntryIterator(this)

		while iterator.hasNext() do
			var e = iterator.next()
			count += 1
			s = s + e.__string__()
			if count < this._count then s += ", " end
		end

		return s + "]"
	end
end

import set

class __KeySet : set.HashSet
	fun new(map)
		this._map = map
	end

	fun contains(e)
		return this._map.__getEntry(e) != null
	end

	fun addAll(iterable)
		raise Exception("addAll not supported in KeySet")
	end

	fun add(e)
		raise Exception("add not supported in KeySet.")
	end

	fun remove(e)
		raise Exception("remove not supported in KeySet.")
	end

	fun removeAll(iterable)
		raise Exception("removeAll not supported in KeySet")
	end

	fun clear()
		raise Exception("clear not supported in KeySet")
	end
end

class __EntryIterator
	fun new(map)
		this.map = map
		this.index = 0
		this.next = null
		this.__nextBucket()
	end

	fun __nextBucket()
		if this.index >= this.map._size then
			return
		end

		while this.index < this.map._size - 1 and this.map._entries[this.index] == null do
			this.index += 1
		end

		this.next = this.map._entries[this.index]
	end

	fun hasNext()
		return this.next != null
	end

	fun next()
		var e = this.next
		this.next = e.next

		if this.next == null then
			this.index += 1
			this.__nextBucket()
		end

		return e
	end

	fun __iterator__()
		return this
	end
end

class __KeyIterator : __EntryIterator
	fun next()
		return super.next().key
	end
end

class __ValueIterator : __EntryIterator
	fun next()
		return super.next().value
	end
end
