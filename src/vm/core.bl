class Number {
	def new() {
		__noinstance(this)
	}
	native __string__()
	native __class__()
	native __hash__()
}
class Boolean {
	def new() {
		__noinstance(this)
	}
	native __string__()
	native __class__()
}
class Null {
	def new() {
		__noinstance(this)
	}
	native __string__()
	native __class__()
}
class Function {
	def new() {
		__noinstance(this)
	}
	native __string__()
}
class Module   {
	def new() {
		__noinstance(this)
	}
	native __string__()
}
class StackTrace {
	def new() {
		__noinstance(this)
	}
}

class String {
	def new() {
		__noinstance(this)
	}

	native __eq__(o)
	native substr(from, to)
	native length()

	def join(iterable) {
		var lst = iterable
		if(!(lst is List)) {
			lst = []
			for(var e in iterable) {
				lst.add(e)
			}
		}
		return this.__join(lst)
	}

	native __join(lst)

	def format(args) {
		var s = ""         // string being built
		var lastf = 0      // index of 1 past the end of last format symbol
		var formatn = 0    // keeps track of the format symbols encountered

		for(var i = 0; i < this.length(); i += 1) {
			//skip escaped char
			if(this[i] == "\\")
				i += 1
			else if(this[i] == "{") {
				var endformat = i

				while(this[endformat] != "}") {
					endformat = endformat + 1
					if(endformat >= this.length()) {
						raise InvalidArgException("Unterminated format.")
					}
				}

				var argn = formatn
				if(endformat - i > 1) {
					try {
						argn = int(this.substr(i + 1, endformat))
					} except(InvalidArgException e) {
						raise InvalidArgException("Invalid format index.")
					}
				}

				s = s + this.substr(lastf, i)
				s = s + args[argn].__string__()

				lastf = endformat + 1
				formatn += 1
			}
		}

		if(lastf < this.length()) {
			s += this.substr(lastf, this.length())
		}

		return s
	}

	def __string__() {
		return this
	}

	def __iterator__() {
		return __StringIterator(this)
	}

	native __hash__()
}

class __StringIterator {
	def new(str) {
		this.str = str
		this.pos = 0
	}

	def hasNext() {
		return this.pos < this.str.length()
	}

	def next() {
		var c = this.str[this.pos]
		this.pos += 1
		return c
	}
}

class List {
	def new() {
		__noinstance(this)
	}

	native add(e)
	native insert(i, e)
	native removeAt(i)
	native size()
	native clear()

	def addAll(iterable) {
		var changed = false
		for(var e in iterable) {
			this.add(e)
			changed = true
		}
		return changed
	}

	def insertAll(iterable, i=0) {
		if(i < 0 or i >= this.size()) {
			raise IndexOutOfBoundException(str(i))
		}

		var changed = false
		for(var e in iterable) {
			this.insert(i, e)
			changed = true
		}
		return changed
	}

	def remove(e) {
		var i = this.indexOf(e)
		if(i >= 0) {
			this.remove(i)
			return true
		}
		return false
	}

	def removeAll(iterable) {
		var changed = false
		for(var e in iterable) {
			var r = this.remove(e)
			changed = changed or r
		}
		return changed
	}

	def contains(e) {
		return this.indexOf(e) != -1
	}

	def indexOf(e) {
		for(var i = 0; i < this.size(); i += 1) {
			if(this[i] == e) {
				return i
			}
		}
		return -1
	}

	def indexOfLast(e) {
		for(var i = this.size() - 1; i >= 0; i -= 1) {
			if(this[i] == e) {
				return i
			}
		}
		return -1
	}

	def swap(a, b) {
		var temp = this[a]
		this[a] = this[b]
		this[b] = temp
	}

	def subList(from, to) {
		if(to < from) {
			raise InvalidArgException("to arg should be >= from arg")
		}

		var sub = []
		for(var i = from; i < to; i += 1) {
			sub.add(this[i])
		}
		return sub
	}

	def empty() {
		return this.size() == 0
	}

	def sort() {
		import rand
		this.__quickSort(0, this.size() - 1)
	}

	def __quickSort(from, to) {
		if(from < to) {
			var p = this.__partition(from, to)

			this.__quickSort(from, p - 1)
			this.__quickSort(p + 1, to)
		}
	}

	def __partition(from, to) {
		var p = rand.randint(from, to + 1)
		this.swap(from, p)

		var piv = this[from]
		var l = from + 1
		var r = to

		while(l <= r) {
			while(this[r] > piv)
				r -= 1
			while(l <= r and this[l] <= piv)
				l += 1

			if(l < r) {
				this.swap(l, r)
				l += 1
				r -= 1
			}
		}

		this.swap(from, r)
		return r
	}

	def __iterator__() {
		return __ListIterator(this)
	}

	def __string__() {
		return "[" + this.join(", ") + "]"
	}

	def __eq__(lst) {
		if(this.size() != lst.size()) {
			return false
		}
		for(var i in range(this.size())) {
			if(this[i] != lst[i]) {
				return false
			}
		}
		return true
	}
}

class __ListIterator {
	def new(list) {
		this.n = 0
		this.list = list
	}

	def hasNext() {
		return this.n < this.list.size()
	}

	def next() {
		var next = this.list[this.n]
		this.n += 1
		return next
	}
}

class __ListReverseIterator {
	def new(list) {
		this.n = list.size() - 1
		this.list = list
	}

	def hasNext() {
		return this.n >= 0
	}

	def next() {
		var prev = this.list[this.n]
		this.n -= 1
		return prev
	}

	def __iterator__() {
		return this
	}
}

def reversed(lst) {
	return __ListReverseIterator(lst)
}

def __noinstance(inst) {
	raise Exception("Class " + inst.__class__().getName() + " cannot be directly instantiated")
}

// Exceptions builtin classes

class Exception {
	def new(err=null) {
		this.err = err
	}
}

class TypeException : Exception {}
class NameException : Exception {}
class FieldException : Exception {}
class MethodException : Exception {}
class ImportException : Exception {}
class StackOverflowException : Exception {}
class DivisionByZeroException : Exception {}
class InvalidArgException : Exception {}
class IndexOutOfBoundException : Exception {}
class AssertException : Exception {}
class IOException : Exception {}

def assert(cond, msg="assertion failed") {
	if(!cond) raise AssertException(msg)
}

def print(o="", file=null) {
	write(o, file)
	__printstr("\n", file)
}

def write(o, file=null) {
	var s = str(o)
	assert(s is String, "__string__() didn't return a string, got " + s.__class__().getName())
	__printstr(s, file)
}

def str(e) {
	return e.__string__()
}

class range {
	def new(from, to=null, step=1) {
		if(to == null) {
			to = from
			from = 0
		}

		if(!isInt(from) or !isInt(to)) {
			raise InvalidArgException("Argument `from` and `to` must be integers")
		}

		this.from = from
		this.to = to
		this.count = from
		this.step = step
	}

	def hasNext() {
		return this.count < this.to
	}

	def next() {
		var i = this.count
		this.count += this.step
		return i
	}

	def __iterator__() {
		return this
	}

	def __string__() {
		var s = "["
		for(var i = this.from; i < this.to; i += 1) {
			s += i.__string__()
			if(i != this.to - 1) s += ", "
		}
		return s + "]"
	}
}

native int(n)
native num(n)
native char(num)
native ascii(char)
native isInt(n)
native list(size=0, init=null)

native __printstr(str, file=null)
